package{	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.*;		import com.perfume.utils.bvh.*;	public class MotionMan3D	{		/** The bvh motion data */		private var _bvh:Bvh;				/** List of circles */		private var _circles:Array;				/** Rendering target */		private var _target:Sprite;				/**		 * Constructor with loading the BVH		 * @param	target		 * @param	path		 */		public function MotionMan3D(target:Sprite, path:String)		{			_target = target;			load(path);		}				public function destroy():void		{			if (_bvh)			{				_bvh.destroy();			}			_bvh = null;						for each (var sp:Sprite in _circles)			{				if (sp.parent)				{					sp.parent.removeChild(sp);				}			}						_circles = null;			_target = null;		}				/** Loads and parse bvh file */		private function load(path:String, onComplete:Function = null):void		{			var loader:URLLoader = new URLLoader();			loader.addEventListener(Event.COMPLETE, function(e:Event):void{				loader.removeEventListener(Event.COMPLETE, arguments.callee);				_bvh = new Bvh(String(loader.data));				_bvh.isLoop = true;								// TODO 5 is the number of bone ends. Should generate number dynamically				createCircles(_bvh.bones.length + 5);								if (onComplete != null ) onComplete();			});						loader.load(new URLRequest(path));		}				/** Creates circle based on num of bones */		private function createCircles(num:int):void		{			_circles = [];			var sp:Sprite;			var col:uint = Math.random() * 0xFFFFFF;			for (var i:int = 0; i < num; i++ )			{				sp = new Sprite();				sp.graphics.beginFill(col, 1);				sp.graphics.drawCircle(0, 0, 4);				_target.addChild(sp);								_circles.push( sp );			}		}				/**		 * Calculate bone position matrix		 *		 * @param	bone The bone input		 * @param	matrix The matrix which will store the result		 */		private function calcBonePosition(bone:BvhBone, matrix:Matrix3D):void		{			// coordinate system in BVH is right-handed.			while (bone)			{				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendRotation(-bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(-bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendTranslation(bone.Xposition + bone.offsetX, bone.Yposition + bone.offsetY, -(bone.Zposition + bone.offsetZ));								bone = bone.parent;			}			// if BVH's coordinate system is left-handed then use below.			/*			while ( bone ) {				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, bone.Zposition+bone.offsetZ);				bone = bone.parent;			}			*/		}		/**		 * Update the motion/animation		 * @param	time		 */		public function update(time:Number):void		{			if (!_bvh )			{				return;			}						//frame of BVH			_bvh.gotoFrame(time / (_bvh.frameTime * 1000));						//calculate joint's position			// TODO optimize this, create positions array after parsing			var positions:Array = [];			for each (var bone:BvhBone in _bvh.bones)			{				var matrix:Matrix3D = new Matrix3D();				calcBonePosition(bone, matrix);				positions.push({ 'bone': bone, 'matrix': matrix });								// endSite				if (bone.isEnd)				{					matrix = new Matrix3D();					matrix.appendTranslation(bone.endOffsetX, bone.endOffsetY, bone.endOffsetZ);					calcBonePosition(bone, matrix);					positions.push({ 'bone': bone, 'matrix': matrix });				}			}						// re-adjust the position			var i:int = 0;			var len:int = positions.length;			var sp:Sprite;			var matPos:Matrix3D;			var tempObj:Object;			for ( i = 0; i < len; i++ )			{				sp = _circles[i];				tempObj = positions[i];				matPos = tempObj.matrix;								sp.x = matPos.position.x  * 2;				sp.y = (-matPos.position.y * 2) + 70;				sp.z = (-matPos.position.z * 2) + 200;			}						drawLines(_target, positions);		}				/**		 *		 * @param	_target		 * @param	a		 */		private function drawLines(target:Sprite, positions:Array):void		{			var i:int = 0;			var len:int = positions.length;			var sp:Sprite;			var sp2:Sprite;			var pt:Point;			var pt2:Point;			var b:BvhBone;			var b2:BvhBone;			var _index:int;			const ZERO:Point = new Point();			var matPos:Matrix3D;			var tempObj:Object;			for (i = 0; i < len; i++)			{				tempObj = positions[i];				b = tempObj.bone as BvhBone;								sp = _circles[i];				pt = sp.localToGlobal(ZERO);								if (b.children.length > 0)				{					for each (b2 in b.children)					{						_index = searchBoneFromBonePositionList(b2, positions);												sp2 = _circles[_index];						pt2 = sp2.localToGlobal(ZERO);						target.graphics.lineStyle(1, 0x777777);						target.graphics.moveTo(pt.x - target.x, pt.y - target.y);						target.graphics.lineTo(pt2.x - target.x, pt2.y - target.y);					}				}				else if ((b.isEnd) && ((i + 1) < len))				{					tempObj = positions[i + 1];					b2 = tempObj.bone as BvhBone;					if (b == b2)					{						_index = i + 1;						sp2 = _circles[_index];						pt2 = sp2.localToGlobal(ZERO);						target.graphics.lineStyle(1, 0x00AAFF);						target.graphics.moveTo(pt.x - target.x, pt.y - target.y);						target.graphics.lineTo(pt2.x - target.x, pt2.y - target.y);					}				}			}		}				/**		 * Search a specified bone from the given list		 *		 * @param	bone The specificed bone we want to search		 * @param	list List of objects containing bone and its matrix		 * @return the index of bone on the list. -1 if no bone found		 */		private function searchBoneFromBonePositionList(bone:BvhBone, list:Array):int		{			// find the index on positions			var found:Boolean = false;			var i:int = 0;			var len:int = list.length;			var tempObject:Object;			while ((i < len) && (!found))			{				tempObject = list[i];				if ((tempObject.bone as BvhBone) == bone)				{					found = true;				}				else				{					i++;				}			}						if (!found)			{				i = -1;			}						return i;		}	}}