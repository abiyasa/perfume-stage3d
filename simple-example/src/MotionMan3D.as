package{	import away3d.containers.ObjectContainer3D;	import away3d.containers.Scene3D;	import away3d.entities.Mesh;	import away3d.materials.ColorMaterial;	import away3d.materials.lightpickers.StaticLightPicker;	import away3d.primitives.CubeGeometry;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.*;		import com.perfume.utils.bvh.*;	public class MotionMan3D	{		/** The bvh motion data */		private var _bvh:Bvh;				/** List of bone points */		private var _bonePoints:Array;				/** Rendering target */		private var _target:Scene3D;				private var _container:ObjectContainer3D;				private var _lightPicker:StaticLightPicker;				/**		 * Constructor with loading the BVH		 * @param	target		 * @param	path		 */		public function MotionMan3D(target:Scene3D, path:String, lightPicker:StaticLightPicker)		{			_target = target;			_container = new ObjectContainer3D();			_target.addChild(_container);			_lightPicker = lightPicker;						load(path);		}				public function destroy():void		{			if (_bvh)			{				_bvh.destroy();			}			_bvh = null;						_target.removeChild(_container);						_container = null;			_bonePoints = null;			_target = null;		}				/** Loads and parse bvh file */		private function load(path:String, onComplete:Function = null):void		{			var loader:URLLoader = new URLLoader();			loader.addEventListener(Event.COMPLETE, function(e:Event):void{				loader.removeEventListener(Event.COMPLETE, arguments.callee);				_bvh = new Bvh(String(loader.data));				_bvh.isLoop = true;								createBonePoints(_bvh.bones);								if (onComplete != null)				{					onComplete();				}			});						loader.load(new URLRequest(path));		}				/** Creates bone points based on list of bones */		private function createBonePoints(listOfBones:Vector.<BvhBone>):void		{			// TODO 5 is the number of bone ends. Should generate number dynamically			var num:int = _bvh.bones.length + 5;						_bonePoints = [];			var cube:Mesh;			var colorMaterial:ColorMaterial = new ColorMaterial(Math.random() * 0xFFFFFF);			colorMaterial.ambientColor = 0xFFFFFF;			colorMaterial.ambient = 0.5;			colorMaterial.specular = 0.1;			colorMaterial.specularLightSources = 4;			colorMaterial.lightPicker = _lightPicker;			for (var i:int = 0; i < num; i++ )			{				cube = new Mesh(new CubeGeometry(20, 20, 20), colorMaterial);				_container.addChild(cube);								_bonePoints.push(cube);								trace("adding cube at " + cube.position.toString());			}		}				/**		 * Calculate bone position matrix		 *		 * @param	bone The bone input		 * @param	matrix The matrix which will store the result		 */		private function calcBonePosition(bone:BvhBone, matrix:Matrix3D):void		{			// coordinate system in BVH is right-handed.			while (bone)			{				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendTranslation(bone.offsetX + bone.Xposition, bone.offsetY + bone.Yposition, bone.offsetZ + bone.Zposition);								bone = bone.parent;			}			// if BVH's coordinate system is left-handed then use below.			/*			while ( bone ) {				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, bone.Zposition+bone.offsetZ);				bone = bone.parent;			}			*/		}		/**		 * Update the motion/animation		 * @param	time		 */		public function update(time:Number):void		{			if (!_bvh )			{				return;			}						//frame of BVH			_bvh.gotoFrame(time / (_bvh.frameTime * 1000));						//calculate joint's position			// TODO optimize this, create positions array after parsing			var positions:Array = [];			for each (var bone:BvhBone in _bvh.bones)			{				var matrix:Matrix3D = new Matrix3D();				calcBonePosition(bone, matrix);				positions.push({ 'bone': bone, 'matrix': matrix });								// endSite				if (bone.isEnd)				{					matrix = new Matrix3D();					matrix.appendTranslation(bone.endOffsetX, bone.endOffsetY, bone.endOffsetZ);					calcBonePosition(bone, matrix);					positions.push({ 'bone': bone, 'matrix': matrix });				}			}						// re-adjust the position			var i:int = 0;			var len:int = positions.length;			var mesh:Mesh;			var matPos:Matrix3D;			var tempObj:Object;			const scale:Number = 3;			for ( i = 0; i < len; i++ )			{				mesh = _bonePoints[i];				tempObj = positions[i];				matPos = tempObj.matrix;								//mesh.x = matPos.position.x  * scale;				//mesh.y = matPos.position.y * scale;				//mesh.z = matPos.position.z * scale;								matPos.appendScale(scale, scale, scale);				mesh.transform = matPos;			}						//drawLines(_target, positions);		}				/**		 *		 * @param	_target		 * @param	a		 */		private function drawLines(target:Sprite, positions:Array):void		{			var i:int = 0;			var len:int = positions.length;			var sp:Sprite;			var sp2:Sprite;			var pt:Point;			var pt2:Point;			var b:BvhBone;			var b2:BvhBone;			var _index:int;			const ZERO:Point = new Point();			var matPos:Matrix3D;			var tempObj:Object;			for (i = 0; i < len; i++)			{				tempObj = positions[i];				b = tempObj.bone as BvhBone;								sp = _bonePoints[i];				pt = sp.localToGlobal(ZERO);								if (b.children.length > 0)				{					for each (b2 in b.children)					{						_index = searchBoneFromBonePositionList(b2, positions);												sp2 = _bonePoints[_index];						pt2 = sp2.localToGlobal(ZERO);						target.graphics.lineStyle(1, 0x777777);						target.graphics.moveTo(pt.x - target.x, pt.y - target.y);						target.graphics.lineTo(pt2.x - target.x, pt2.y - target.y);					}				}				else if ((b.isEnd) && ((i + 1) < len))				{					tempObj = positions[i + 1];					b2 = tempObj.bone as BvhBone;					if (b == b2)					{						_index = i + 1;						sp2 = _bonePoints[_index];						pt2 = sp2.localToGlobal(ZERO);						target.graphics.lineStyle(1, 0x00AAFF);						target.graphics.moveTo(pt.x - target.x, pt.y - target.y);						target.graphics.lineTo(pt2.x - target.x, pt2.y - target.y);					}				}			}		}				/**		 * Search a specified bone from the given list		 *		 * @param	bone The specificed bone we want to search		 * @param	list List of objects containing bone and its matrix		 * @return the index of bone on the list. -1 if no bone found		 */		private function searchBoneFromBonePositionList(bone:BvhBone, list:Array):int		{			// find the index on positions			var found:Boolean = false;			var i:int = 0;			var len:int = list.length;			var tempObject:Object;			while ((i < len) && (!found))			{				tempObject = list[i];				if ((tempObject.bone as BvhBone) == bone)				{					found = true;				}				else				{					i++;				}			}						if (!found)			{				i = -1;			}						return i;		}	}}